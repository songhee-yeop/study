# 카프카 프로듀서: 카프카에 메시지 쓰기
- 카프카 프로듀서 사용법 배움
- 프로듀서 디자인, 주요 요소의 전체적 모습, 객체 생성 등

## 3.1 프로듀서 개요
- 카프카에 메시지를 써야 하는상황 
  - 감사 혹은 분석목적으로 한 사용자 행동 기록
  - 메트릭 기록
  - 로그 메시지 저장
- 사례도 다양
  - 메시지 유실 용납 여부
  - 중복 허용여부
  - 지연 처리율 있는지?
- 카프카에 메시지를 쓰는 작업은 ProducerRecord 객체를 생성함으로써 시작
- 토픽 밸류지정은 필수, 키와 파티션 지정은 선택
- ProducerRecord를 전송하는 API 호출 시 프로듀서는 키와 값 객체가 네트워크 상에서 전송될 수 있도록 직렬화해서 바이트 배열로 변환
- 파티션을 명시적으로 지정하지 않았따면 해당 데이터를 파티셔너에게 보냄
## 3.2 카프카 프로듀서 생성하기
- 메시지를 쓰려면 객체를 생성해야 하는데 카프카 프로듀서는 3개의 필수 속성값 가짐
- bootstrap.servers
  - 프로듀서가 사용할 브로커의 host:port목록
  - 최소 2개 이상 권장
- key.serializer
  - 프로튜서 인터페이스는 임의의 자바 객체를 키 혹은 밸류로 전송할 수 있도록 매개변수화된 타입을 사용할수 있게 한다.
  - 키 직렬화
- value.serializer
  - 밸류 직렬화
~~~java
Properties kafkaProps = new Properties();
kafkaProps.put("bootstrap.servers", "broker1:9092, broker2:9092");
kafkaProps.put("key.sserializer", "org.apache.kafka.common.serialization.StringSerializer");
kafkaProps.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

kafkaProducer<String, String> producer. = new KafkaProducer<String, String>(kafkaProps);
~~~
- 메시지 전송 방법
  - 파이어 앤 포겟
    - 전송만 하고 성공여부 신경 안씀
  - 동기적 전송
    - 성공여부 확인
  - 비동기적 전송
    - send()호출하면 카프카 브로커로부터 응답을 받는 시점으로 콜백함수 호출

## 3.3 카프카로 메시지 전달
~~~java
ProducerRecord<String, String> record = new ProducerRecord<>("CustomerCountry", "Precision Products", "France");
try {
    producer.send();
} catch( Exception e) {
  e.printStackTrace();
}
~~~

### 3.3.1 동기적으로 메시지 전송하기
- 주요 균형점은 성능
- 성능이 낮으므로 실제로 잘 사용되지 않음
~~~java
ProducerRecord<String, String> record = new ProducerRecord<>("CustomerCountry", "Precision Products", "France");
try {
    producer.send().get(); //Future.get 메소드 사용
} catch( Exception e) {
  e.printStackTrace();
}
~~~

### 3.3.2 비동기적으로 메시지 전송
- 메시지를 비동기적으로 전송하고도 에러 처리 위해 프로듀서는 레고드를 전송할 때 콜백 지정 가능
~~~java
private class DemoProducerCallback implements Callback {
    @Override
    public void onCompletion(RecordMetadata recordMetadata, Exception e) {
        if(e != null) {
            e.printStackTrace();
        }
    }
}

ProducerRecord<String, String> record = new ProducerRecord<>("CustomerCountry", "Precision Products", "France");
producer.send(record, new DemoProducerCallback());
~~~

### 3.4 프로듀서 설정하기

### 3.4.1 client.id
- 논리적 식별자

### 3.4.2 acks
- 프로듀서가 임의의 쓰기 작업이 성공했다고 판별하기 위해 얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는지 결정
- 기본값은 리더가 해당 레코드를 받은 뒤 쓰기 작업이 성공했다고 응답
- acks=0일때
  - 성공 간주 브로커의 응답 기자리지 않음
  - 매우 높은 처리량이 필요할 때 사용
- acks=1
  - 프로듀서는 리더 레플리카가 메시지를 받는 순간 브로커로부터 성공했다는 응답 받음
  - 리더에 크래시가 난 상태면 메시지 유실 가능
- acks=all
  - 모든 인 싱크 레플리카에 전달된 뒤에야 성공 응답 받음 
  - 가장 안전
  - 지연이 길다.

### 3.4.3 메시지 전달 시간
- 카프카 2.1부터 시간을 두 구간으로 분리
  - send()에 대한 비동기 호출 시작 시작부터 리턴 시간
  - send()에 대한 비동기 호출이 성공적 리턴 시각부터 콜백이 호출될 떄 걸리는 시간
1. max.block.ms
   - 프로듀서가 얼마나 오랫동안 블록되는지 결정
2. delivery.timeout.ms
    - 레코드 전송 준비가 완로된 시점에서부터 브로커의 응답을 받거나 아니면 전송을 포기하게 되는 시점까지의 제한시간을 결정한다.
    - 이 값은 linger.ms와 request.timeout.ms보다 커야 한다.
    - 보통 이것보다 메시지는 빨리 전송
3. request.timeout.ms
    - 프로듀서가 데이터를 전송할 때 서버로부터 응답 받기 위해 얼마나 기다릴것인지 결정
    - 이 값은 각각의 쓰기 요청 후 전송을 포기하기까지의 대기 시간임
4. retries, retry.backoff.ms
    - 